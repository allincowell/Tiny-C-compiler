#ifndef ASS6_18CS30032_18CS10068_TRANSLATOR_H
#define ASS6_18CS30032_18CS10068_TRANSLATOR_H

using namespace std;
#include <stdio.h>
#include <vector>
#include <cstdlib>
#include <string>
#include <set>
#include <map>
#include <stack>

struct decStr;
struct exp;
struct idStr;
struct arglistStr;

class type_n;
class quad;
class exp;
class symbolData;
class quadArray; 
class Array;
class symtab;
class funct;

extern stack<int> types_stack, offset_stack, ptrarr_stack;
extern map<int, int> mp_set;
extern quadArray glob_quad; 					// for storing quads that will be generated by the grammar
extern int size_bool, size_int, size_double, size_pointer, size_char;
extern stack<string> params_stack, strin;
extern int glob_width, next_instr, temp_count; 
extern vector<string> strings_label;
extern type_n *glob_type;
extern symtab *glob_st, *curr_st; 				// global pointer for symbol table

enum types
{
	tp_void = 0, tp_bool,
	tp_arr,	tp_func,
	tp_char,	tp_int,
	tp_double,	tp_ptr,
};

// basic data types for an identifier
union basic_val
{
	int int_val;
	double double_val;
	char char_val;
};

typedef struct list
{
	int index;
	struct list *next;
}list;

enum opcode{
	// operators for binary assignment
	Q_PLUS = 1,
	Q_MINUS,
	Q_MULT,
	Q_DIVIDE,
	Q_MODULO,
	Q_LEFT_OP,
	Q_RIGHT_OP,
	Q_XOR,
	Q_AND,
	Q_OR,
	Q_LOG_AND,
	Q_LOG_OR,
	Q_LESS,
	Q_LESS_OR_EQUAL,
	Q_GREATER_OR_EQUAL,
	Q_GREATER,
	Q_EQUAL,
	Q_NOT_EQUAL,

	// operators for unary assignment
	Q_UNARY_MINUS,
	Q_UNARY_PLUS,
	Q_COMPLEMENT,
	Q_NOT,

	// operators for copy assignment
	Q_ASSIGN,
	Q_GOTO,

	// conditional jump
	Q_IF_EQUAL,
	Q_IF_NOT_EQUAL,
	Q_IF_EXPRESSION,
	Q_IF_NOT_EXPRESSION,
	Q_IF_LESS,
	Q_IF_GREATER,
	Q_IF_LESS_OR_EQUAL,
	Q_IF_GREATER_OR_EQUAL,

	// type conversions
	Q_CHAR2INT,
	Q_CHAR2DOUBLE,
	Q_INT2CHAR,
	Q_DOUBLE2CHAR,
	Q_INT2DOUBLE,
	Q_DOUBLE2INT,


	// funtion Call
	Q_PARAM,
	Q_CALL,
	Q_RETURN,

	// operators for pointer assignment
	Q_LDEREF,
	Q_RDEREF,
	Q_ADDR,

	// array indexing
	Q_RINDEX,
	Q_LINDEX,

};

void conv2Bool(exp *); 				// converts given exprssion type to bool mostly used in relational operator
void backpatch(list *, int );
void update_nextinstr();
type_n *CopyType(type_n *);
void typecheck(exp *, exp *, bool isAss = false);
void print_list(list *);
list* makelist(int );  
list* merge(list *, list *); 

class type_n{
public:
	int size;										// size of type
	types basetp; 									// basic type
	type_n *next;									// save next type_n type for arrays
	type_n(types t,int sz = 1, type_n *n = NULL);	// constuctor
	int getSize();									// returns size
	types getBasetp();								// returns base type
	void printSize();								// prints size
	void print(); 
};

// stores details of functions (parameters and return type)
class funct
{
public:
	vector<types> typelist;		// parameter type
	type_n *rettype;			// return type

	funct(vector<types> );
	void print();
};

class symtab{
public:
	string name;									// name of symbol
	int offset, start_quad, end_quad;				// final offset of this symbol table that will be used in the update function
	vector<symbolData*> symbol_table;					// maintains a list of symbol tables
	int no_params;

	symtab();
	~symtab();

	symbolData* lookup(string );			// lookup function for variables. If present then returns its pointer location else creates a new entry and returns that pointer
	symbolData* lookup_global(string );	// handles global variables
	symbolData* find(string );				// searches for the variable
	symbolData* gentemp(type_n* ); 		// creates a new element in the symbol table with the type provided at the time of constructing
	
	void print();
	void update(symbolData*, type_n*, basic_val , symtab *next = NULL);	
	void mark_labels();
	void function_prologue(FILE*, int );
	void global_variables(FILE *);
	void gen_internal_code(FILE *, int);
	int function_call(FILE *);
	void function_epilogue(FILE *, int, int);
	string assign_reg(int, int );
	void assign_offset();
	void function_restore(FILE *);
	int findg(string);
};

// class for building elements in symbol table
class symbolData{
public:
	string name, var_type;
	int offset, size;
	basic_val i_val;		// stores initialized value for an element in symbol table
	type_n *tp_n;			// stores type of element
	symtab *nest_tab;		// stores the pointer to the symbol table to which the current element belongs to
	Array *arr;				// stores the pointer to an Array if its an Array type
	funct *fun;				// stores the pointer to a function if its a function
	void createArray();
	symbolData(string n = "");	// name is initialized to null which will be used for naming temporary variables
	bool isGlobal, isdone, ispresent, isptrarr, isArray, isFunction, isInitialized;
};

class Array
{
public:

	string base_arr;
	Array(string ,int ,types );
	types tp;
	vector<int> dims;
	int bsize,dimension_size;
	void addindex(int );

};	

struct decStr
{
	type_n *type;				// type of current declaration
	int width;					// width of variable
};

struct exp
{
	symbolData* loc;
	type_n* type;
	list* falselist, *truelist;
	bool isArray, isPointer, isString;
	int ind_str;
	symbolData *poss_Array, *arr;
};

// struct for an identifier
struct idStr
{
	symbolData *loc;					// pointer to symboltable
	string *name;					// name of identifier
};

class quad
{
public:
	string arg1, result, arg2; 
	opcode op;
	void print_arg();
	quad(opcode, string, string, string);
};

class quadArray{
public:
	vector<quad> arr;															// stores list of quads
	quadArray();
	void emit(opcode , string def1 = "", string def2 = "", string res = ""); 	// for operations with 3 inputs
	void emit(opcode , int , string operand = "");  							// for assignment of int
	void emit(opcode , double , string operand = ""); 							// for assignment of double
	void emit(opcode , char , string operand = ""); 							// for assignment of char
	void emit2(opcode,string arg1 = "", string arg2 = "", string result = "");
	void print();  																// prints all quads
};

struct arglistStr
{
	vector<exp*> *arguments;
};

struct strstr
{
	type_n lop;
	string name;
};

#endif
